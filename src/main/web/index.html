<!DOCTYPE html>
<meta charset="utf-8">
<style>

    .links line {
        stroke: #999;
        stroke-opacity: 0.6;
    }

    .nodes circle {
        stroke: #fff;
        stroke-width: 1.5px;
    }

    text {
        /*visibility: hidden;*/
        font: 12px sans-serif;
    }

</style>

<svg id="canvas" width="1200" height="900">
</svg>

<button onclick="zoomIn()">Zoom in</button>
<button onclick="zoomOut()">Zoom out</button>
<button onclick="resetZoom()">Reset zoom</button>
<button onclick="panLeft()">Pan left</button>
<button onclick="panRight()">Pan right</button>
<button onclick="center()">Center</button>

<input type="range" id="number-of-links" min="0" max="800" value="450" step="10" onchange="loadJson(this.value)" style="width: 900px;">
<span id="graph-size"></span>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-sankey/0.12.3/d3-sankey.min.js"></script>
<script>
    // Copyright 2021 Observable, Inc.
    // Released under the ISC license.
    // https://observablehq.com/@d3/force-directed-graph
    function ForceGraph({
                            nodes, // an iterable of node objects (typically [{id}, …])
                            links // an iterable of link objects (typically [{source, target}, …])
                        }, {
                            nodeId = d => d.id, // given d in nodes, returns a unique identifier (string)
                            nodeGroup, // given d in nodes, returns an (ordinal) value for color
                            nodeGroups, // an array of ordinal values representing the node groups
                            nodeTitle, // given d in nodes, a title string
                            nodeFill = "currentColor", // node stroke fill (if not using a group color encoding)
                            nodeStroke = "#fff", // node stroke color
                            nodeStrokeWidth = 1.5, // node stroke width, in pixels
                            nodeStrokeOpacity = 1, // node stroke opacity
                            nodeRadius = 5, // node radius, in pixels
                            nodeStrength,
                            linkSource = ({source}) => source, // given d in links, returns a node identifier string
                            linkTarget = ({target}) => target, // given d in links, returns a node identifier string
                            linkStroke = "#999", // link stroke color
                            linkStrokeOpacity = 0.6, // link stroke opacity
                            linkStrokeWidth = 1.5, // given d in links, returns a stroke width in pixels
                            linkStrokeLinecap = "round", // link stroke linecap
                            linkStrength,
                            colors = d3.schemeTableau10, // an array of color strings, for the node groups
                            width = 640, // outer width, in pixels
                            height = 400, // outer height, in pixels
                            invalidation // when this promise resolves, stop the simulation
                        } = {}) {
        // Compute values.
        const N = d3.map(nodes, nodeId).map(intern);
        const LS = d3.map(links, linkSource).map(intern);
        const LT = d3.map(links, linkTarget).map(intern);
        if (nodeTitle === undefined) nodeTitle = (_, i) => N[i];
        const T = nodeTitle == null ? null : d3.map(nodes, nodeTitle);
        const G = nodeGroup == null ? null : d3.map(nodes, nodeGroup).map(intern);
        const W = typeof linkStrokeWidth !== "function" ? null : d3.map(links, linkStrokeWidth);
        const L = typeof linkStroke !== "function" ? null : d3.map(links, linkStroke);

        // Replace the input nodes and links with mutable objects for the simulation.
        nodes = d3.map(nodes, (_, i) => ({id: N[i]}));
        links = d3.map(links, (_, i) => ({source: LS[i], target: LT[i]}));

        // Compute default domains.
        if (G && nodeGroups === undefined) nodeGroups = d3.sort(G);

        // Construct the scales.
        const color = nodeGroup == null ? null : d3.scaleOrdinal(nodeGroups, colors);

        // Construct the forces.
        const forceNode = d3.forceManyBody().strength(-100);
        const forceLink = d3.forceLink(links).id(({index: i}) => N[i]);
        if (nodeStrength !== undefined) forceNode.strength(nodeStrength);
        if (linkStrength !== undefined) forceLink.strength(linkStrength);

        let zoom = d3.zoom().scaleExtent([0.25, 1000]).on('zoom', handleZoom)

        const simulation = d3.forceSimulation(nodes)
            .force("link", forceLink)
            .force("charge", forceNode)
            .force("x", d3.forceX()) // .force("center",  d3.forceCenter())
            .force("y", d3.forceY())
            .on("tick", ticked);


        const svg = d3.select("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [-width / 2, -height / 2, width, height])
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

        const link = svg.append("g")
            .attr("stroke", typeof linkStroke !== "function" ? linkStroke : null)
            .attr("stroke-opacity", linkStrokeOpacity)
            .attr("stroke-width", typeof linkStrokeWidth !== "function" ? linkStrokeWidth : null)
            .attr("stroke-linecap", linkStrokeLinecap)
            .selectAll("line")
            .data(links)
            .join("line");

        const node = svg.append("g")
            .attr("fill", nodeFill)
            .attr("stroke", nodeStroke)
            .attr("stroke-opacity", nodeStrokeOpacity)
            .attr("stroke-width", nodeStrokeWidth)
            .selectAll("g")
            .data(nodes)
            .join("g")
            .call(drag(simulation));

        node.append('circle')
            .attr("stroke", "white")
            .attr("stroke-width", 1.5)
            .attr("r", nodeRadius)
            .attr("onclick", "this.parentElement.getElementsByTagName('text')[0].classList.toggle('show-text')")

        svg.call(zoom)

        if (W) link.attr("stroke-width", ({index: i}) => W[i]);
        if (L) link.attr("stroke", ({index: i}) => L[i]);
        if (G) node.attr("fill", ({index: i}) => color(G[i]));
        if (T) node.append("text")
            .attr("x", 8)
            .attr("y", "0.31em")
            .attr("fill", "black")
            .attr("stroke", "black")
            .attr("stroke-width", 0.5)
            .text(({index: i}) => T[i]);
        if (invalidation != null) invalidation.then(() => simulation.stop());

        function intern(value) {
            return value !== null && typeof value === "object" ? value.valueOf() : value;
        }

        function ticked() {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node.attr("transform", d => `translate(${d.x},${d.y})`);
            // node
            //     .attr("cx", d => d.x)
            //     .attr("cy", d => d.y);
        }

        function drag(simulation) {
            function dragStarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            function dragEnded(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }

            return d3.drag()
                .on("start", dragStarted)
                .on("drag", dragged)
                .on("end", dragEnded);
        }

        function handleZoom(e) {
            // node.attr('transform', e.transform)
            node.selectAll("circle").attr("r", 2.1 - (e.transform / 10))
            node.selectAll('circle').attr('transform', "translate(" + e.transform.x + "," + e.transform.y + ") scale(" + e.transform.k + ")")
            node.selectAll('text').attr('transform', "translate(" + e.transform.x + "," + e.transform.y + ") scale(" + e.transform.k + ")")
            link.attr('transform', "translate(" + e.transform.x + "," + e.transform.y + ") scale(" + e.transform.k + ")")
        }

        return Object.assign(svg.node(), {scales: {color}});
    }

    // Copyright 2021 Observable, Inc.
    // Released under the ISC license.
    // https://observablehq.com/@d3/sankey-diagram
    function SankeyChart({
                             nodes, // an iterable of node objects (typically [{id}, …]); implied by links if missing
                             links // an iterable of link objects (typically [{source, target}, …])
                         }, {
                             format = ",", // a function or format specifier for values in titles
                             align = "justify", // convenience shorthand for nodeAlign
                             nodeId = d => d.id, // given d in nodes, returns a unique identifier (string)
                             nodeGroup, // given d in nodes, returns an (ordinal) value for color
                             nodeGroups, // an array of ordinal values representing the node groups
                             nodeLabel, // given d in (computed) nodes, text to label the associated rect
                             nodeTitle = d => `${d.id}\n${format(d.value)}`, // given d in (computed) nodes, hover text
                             nodeAlign = align, // Sankey node alignment strategy: left, right, justify, center
                             nodeWidth = 15, // width of node rects
                             nodePadding = 10, // vertical separation between adjacent nodes
                             nodeLabelPadding = 6, // horizontal separation between node and label
                             nodeStroke = "currentColor", // stroke around node rects
                             nodeStrokeWidth, // width of stroke around node rects, in pixels
                             nodeStrokeOpacity, // opacity of stroke around node rects
                             nodeStrokeLinejoin, // line join for stroke around node rects
                             linkSource = ({source}) => source, // given d in links, returns a node identifier string
                             linkTarget = ({target}) => target, // given d in links, returns a node identifier string
                             linkValue = ({value}) => value, // given d in links, returns the quantitative value
                             linkPath = d3.sankeyLinkHorizontal(), // given d in (computed) links, returns the SVG path
                             linkTitle = d => `${d.source.id} → ${d.target.id}\n${format(d.value)}`, // given d in (computed) links
                             linkColor = "source-target", // source, target, source-target, or static color
                             linkStrokeOpacity = 0.5, // link stroke opacity
                             linkMixBlendMode = "multiply", // link blending mode
                             colors = d3.schemeTableau10, // array of colors
                             width = 640, // outer width, in pixels
                             height = 400, // outer height, in pixels
                             marginTop = 5, // top margin, in pixels
                             marginRight = 1, // right margin, in pixels
                             marginBottom = 5, // bottom margin, in pixels
                             marginLeft = 1, // left margin, in pixels
                         } = {}) {
        // Convert nodeAlign from a name to a function (since d3-sankey is not part of core d3).
        if (typeof nodeAlign !== "function") nodeAlign = {
            left: d3.sankeyLeft,
            right: d3.sankeyRight,
            center: d3.sankeyCenter
        }[nodeAlign] ?? d3.sankeyJustify;

        // Compute values.
        const LS = d3.map(links, linkSource).map(intern);
        const LT = d3.map(links, linkTarget).map(intern);
        const LV = d3.map(links, linkValue);
        if (nodes === undefined) nodes = Array.from(d3.union(LS, LT), id => ({id}));
        const N = d3.map(nodes, nodeId).map(intern);
        const G = nodeGroup == null ? null : d3.map(nodes, nodeGroup).map(intern);

        // Replace the input nodes and links with mutable objects for the simulation.
        nodes = d3.map(nodes, (_, i) => ({id: N[i]}));
        links = d3.map(links, (_, i) => ({source: LS[i], target: LT[i], value: LV[i]}));

        // Ignore a group-based linkColor option if no groups are specified.
        if (!G && ["source", "target", "source-target"].includes(linkColor)) linkColor = "currentColor";

        // Compute default domains.
        if (G && nodeGroups === undefined) nodeGroups = G;

        // Construct the scales.
        const color = nodeGroup == null ? null : d3.scaleOrdinal(nodeGroups, colors);

        // Compute the Sankey layout.
        d3.sankey()
            .nodeId(({index: i}) => N[i])
            .nodeAlign(nodeAlign)
            .nodeWidth(nodeWidth)
            .nodePadding(nodePadding)
            .extent([[marginLeft, marginTop], [width - marginRight, height - marginBottom]])
            ({nodes, links});

        // Compute titles and labels using layout nodes, so as to access aggregate values.
        if (typeof format !== "function") format = d3.format(format);
        const Tl = nodeLabel === undefined ? N : nodeLabel == null ? null : d3.map(nodes, nodeLabel);
        const Tt = nodeTitle == null ? null : d3.map(nodes, nodeTitle);
        const Lt = linkTitle == null ? null : d3.map(links, linkTitle);

        // A unique identifier for clip paths (to avoid conflicts).
        const uid = `O-${Math.random().toString(16).slice(2)}`;

        const svg = d3.select("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [0, 0, width, height])
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

        const node = svg.append("g")
            .attr("stroke", nodeStroke)
            .attr("stroke-width", nodeStrokeWidth)
            .attr("stroke-opacity", nodeStrokeOpacity)
            .attr("stroke-linejoin", nodeStrokeLinejoin)
            .selectAll("rect")
            .data(nodes)
            .join("rect")
            .attr("x", d => d.x0)
            .attr("y", d => d.y0)
            .attr("height", d => d.y1 - d.y0)
            .attr("width", d => d.x1 - d.x0);

        if (G) node.attr("fill", ({index: i}) => color(G[i]));
        if (Tt) node.append("title").text(({index: i}) => Tt[i]);

        const link = svg.append("g")
            .attr("fill", "none")
            .attr("stroke-opacity", linkStrokeOpacity)
            .selectAll("g")
            .data(links)
            .join("g")
            .style("mix-blend-mode", linkMixBlendMode);

        if (linkColor === "source-target") link.append("linearGradient")
            .attr("id", d => `${uid}-link-${d.index}`)
            .attr("gradientUnits", "userSpaceOnUse")
            .attr("x1", d => d.source.x1)
            .attr("x2", d => d.target.x0)
            .call(gradient => gradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", ({source: {index: i}}) => color(G[i])))
            .call(gradient => gradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", ({target: {index: i}}) => color(G[i])));

        link.append("path")
            .attr("d", linkPath)
            .attr("stroke", linkColor === "source-target" ? ({index: i}) => `url(#${uid}-link-${i})`
                : linkColor === "source" ? ({source: {index: i}}) => color(G[i])
                    : linkColor === "target" ? ({target: {index: i}}) => color(G[i])
                        : linkColor)
            .attr("stroke-width", ({width}) => Math.max(1, width))
            .call(Lt ? path => path.append("title").text(({index: i}) => Lt[i]) : () => {});

        if (Tl) svg.append("g")
            .attr("font-family", "sans-serif")
            .attr("font-size", 10)
            .selectAll("text")
            .data(nodes)
            .join("text")
            .attr("x", d => d.x0 < width / 2 ? d.x1 + nodeLabelPadding : d.x0 - nodeLabelPadding)
            .attr("y", d => (d.y1 + d.y0) / 2)
            .attr("dy", "0.35em")
            .attr("text-anchor", d => d.x0 < width / 2 ? "start" : "end")
            .text(({index: i}) => Tl[i]);

        function intern(value) {
            return value !== null && typeof value === "object" ? value.valueOf() : value;
        }

        return Object.assign(svg.node(), {scales: {color}});
    }

    const loadJson = (numberOfLinks) => d3.json("scala_callgraph_collar_2.13-0.1.unknown.jar_2022-04-22T12:34:11.225561Z.json").then(graph => {
        console.log('Graph is parsed')

        function uniqBy(a, key) {
            let seen = new Set();
            return a.filter(item => {
                let k = key(item);
                return seen.has(k) ? false : seen.add(k);
            });
        }

        // graph.links = graph.links.sort((a, b) => b.value - a.value).filter(l => l.value > numberOfLinks)
        graph.links = graph.links
            .filter(l => l.source !== l.target) // remove self references
            .filter(l => l.value > numberOfLinks) // remove weak links, not well-connected classes
        const sourceClazz = new Set(graph.links.map(link => link.source))
        const targetClazz = new Set(graph.links.map(link => link.target))
        graph.nodes = uniqBy(graph.nodes, JSON.stringify) // remove duplicate nodes
        graph.nodes = graph.nodes.filter(node => (sourceClazz.has(node.id) || targetClazz.has(node.id)))
        document.getElementById("graph-size").textContent = "Links: " + graph.links.length + ", Nodes: " + graph.nodes.length

        let invalidation = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('foo')
            }, 1000)
        })
        const e = document.getElementById('canvas')
        let child = e.lastElementChild
        while (child) {
            e.removeChild(child);
            child = e.lastElementChild
        }

        SankeyChart(graph, {
            nodeGroup: d => d.id.split(/\W/)[0], // take first word for color
            nodeAlign: d3.sankeyJustify, // e.g., d3.sankeyJustify; set by input above
            linkColor: "source", // e.g., "source" or "target"; set by input above
            format: (f => d => `${f(d)} TWh`)(d3.format(",.1~f")),
            width: 1200,
            height: 1900
        })

        // ForceGraph(graph, {
        //     nodeId: d => d.id,
        //     nodeGroup: d => d.group,
        //     nodeTitle: d => d.id,
        //     linkStrokeWidth: l => l.value,
        //     // linkStrength: 0.2,
        //     // nodeStrength: -0.002,
        //     nodeRadius: 5,
        //     width: 1200,
        //     height: 900,
        //     invalidation // a promise to stop the simulation when the cell is re-run
        // })
    })

    console.log('Loading json')
    loadJson(document.getElementById("number-of-links").value)
</script>